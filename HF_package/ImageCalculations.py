# Author: Flavian Tschurr
# Project: Herbifly
# Script use: provides various functions applied on images
# Date: 06.05.2020

########################################################################################################################
# imports
########################################################################################################################

import cv2
import numpy as np
import pandas as pd


# make a rgb picture in gray
def rgb2gray(rgb):
    """ makes an rgb picture into a gray
       :param rgb: rgb picture
       :return: a gray scaled picture
       """
    r,g,b = rgb[:,:,0],rgb[:,:,1],rgb[:,:,2]
    gray = 0.2989 * r + 0.5870 * g + 0.1140 * b
    return gray


def get_colorspaces_8bit(a_8bit_img, pixel_shift=0):
    """Gets a rawpy.RawPy object and generates 16 bit RGB, HSV, Lab and ExG/ExR representants -> adapted from Luaks

       :param pixel_shift: Offset pixel used to cutout border pixel
       :return: tuple of RGB, HSV, and Lab (all 0..1 float32) and ExG and ExR (n..m float32)
       :return: descriptors as numpy array
       :return: descriptor names
       """

    a_XYZ_8bit = a_8bit_img
    # Cut image
    a_XYZ_8bit = a_XYZ_8bit[
                 pixel_shift :a_XYZ_8bit.shape[0] - pixel_shift,
                 pixel_shift :a_XYZ_8bit.shape[1] - pixel_shift,
                 :
                 ]

    # Convert XYZ to RGB space using opencv (cv2)
    a_RGB_8bit = cv2.cvtColor(a_XYZ_8bit,cv2.COLOR_XYZ2RGB)

    # Scale to 0...1 ----> das wird failen! float anpassne?
    # a_RGB_8bitf = np.array(a_RGB_8bit / 2 ** 16, dtype=np.float32)
    a_RGB_8bitf = np.array(a_RGB_8bit / 2 ** 8,dtype=np.float32)

    # Convert to HSV space using opencv (cv2)
    a_HSV_8bitf = cv2.cvtColor(a_RGB_8bitf,cv2.COLOR_RGB2HSV)

    # Convert to LAB space using opencv (cv2)
    a_Lab_8bitf = cv2.cvtColor(a_RGB_8bitf,cv2.COLOR_RGB2Lab)

    # Calcualte vegetation indices: ExR and ExG
    R,G,B = cv2.split(a_RGB_8bit)
    normalizer = np.array(R + G + B,dtype=np.float32)
    # Avoid division by zero
    normalizer[normalizer == 0] = 1
    r,g,b = (R,G,B) / normalizer
    # ExR + ExG
    a_ExR = np.array(1.4 * r - b,dtype=np.float32)
    a_ExG = np.array(2.0 * g - r - b,dtype=np.float32)

    # Concat all
    descriptors = np.concatenate(
        [a_XYZ_8bit,a_RGB_8bitf,a_HSV_8bitf,a_Lab_8bitf,np.stack([a_ExG,a_ExR],axis=2)],axis=2)
    # Names
    descriptor_names = ['X','Y','Z','sR','sG','sB','H','S','V','L','a','b','ExR','ExG']

    # Return as tuple
    return ((a_XYZ_8bit,a_RGB_8bitf,a_HSV_8bitf,a_Lab_8bitf,a_ExG,a_ExR),descriptors,descriptor_names)


    # cut a image in slices (default 3 by 3)
def image_slicer(pictureCurrent, heightDivider=3, widthDivider=3):
    """ slices an image into given tiles defined by cutting into x and y direction
       :param pictureCurrent: input picture
       :param heightDivider: how many tiles in the height directon
       :param widthDivider: how many tiles in width direction
       :return: list with the tiles stored in it and a list with the image coordinates to stitch them together again
       """
    height, width, _ = pictureCurrent.shape
    picSlices = []
    picCoords = []
    cols = ["height_from", "height_to", "width_from", "width_to"]

    width_add = width / widthDivider
    height_add = height / heightDivider
    h_range = heightDivider - 1
    w_range = widthDivider - 1
    for h in range(0, heightDivider) :
        for w in range(0, widthDivider) :
            height_from = int(h * height_add)
            height_to = int((h + 1) * height_add)
            width_from = int(w * width_add)
            width_to = int((w + 1) * width_add)
            pic = pictureCurrent[height_from :height_to, width_from :width_to]
            picSlices.append(pic)
            picCoords.append([height_from, height_to, width_from, width_to])

    coordinatesSlices = pd.DataFrame(picCoords, columns=cols)

    return picSlices, coordinatesSlices


     # stitch sliced pictures together again
def image_stitcher(segmentationPics,coordinates):
    """ stitches the sliced pictures together again
    :param segmentationPics: list with the picture slices
    :param coordinates: coordiantes generated by slicing the picture into tiules
    :return: the stitched picture
    """
    picture = np.empty(shape=(coordinates.height_to.max(),coordinates.width_to.max()),dtype=np.uint8)
    for slice in range(len(segmentationPics)) :
        picture[coordinates.height_from[slice] :coordinates.height_to[slice],
        coordinates.width_from[slice] :coordinates.width_to[slice]] = segmentationPics[slice]
    return picture


    # classification routine
def brightness_classifier(pictureCurrent):
    ''' calclulates the brighness of the input by converting it into gray scale and take the mean value.
    this is sued to classify the picture
    :param pictureCurrent: inoput picture (respetively picture tile)
    :return: class value
    '''
    # make RGB to gray (black white
    gray = rgb2gray(pictureCurrent)
    brightness_value = gray.mean()

    if brightness_value < 90:
        class_value = "a"
    elif 90 < brightness_value < 95:
        class_value = "b"
    elif 95 < brightness_value < 100:
        class_value = "c"
    elif 100 < brightness_value < 105:
        class_value = "d"
    elif 105 < brightness_value < 110:
        class_value = "e"
    elif 110 < brightness_value < 115:
        class_value = "f"
    elif brightness_value > 115:
        class_value = "g"
    return class_value
